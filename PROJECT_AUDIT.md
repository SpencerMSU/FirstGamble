# Аудит проекта FirstGamble

В роли Senior Full Stack разработчика я провел анализ архитектуры, безопасности и кодовой базы проекта. Ниже представлен отчет с выявленными проблемами, нелогичностями и предложениями по оптимизации.

## 1. Критические уязвимости и безопасность

### 1.1. Полное доверие клиенту (Client-Side Trust)
**Проблема:** Самая критичная уязвимость. Эндпоинты `/api/add_point` и `/api/report_game` полагаются на данные, присланные клиентом.
*   В `doodle.html` (и других мини-играх) JS отправляет `{delta: 1}` или `{result: 'win'}`.
*   Злоумышленник может скопировать свой `X-Telegram-InitData` и отправлять CURL-запросы в цикле, накручивая баланс до бесконечности без реальной игры.
*   Валидация `delta <= 0` в `routes.py` не спасает от отправки тысяч запросов с `delta=1`.

**Решение:**
*   **Подписывание результатов:** Генерировать на сервере уникальный токен начала игры (`game_session_id`). При завершении игры клиент отправляет этот токен вместе с зашифрованной (или хотя бы обфусцированной) строкой результата.
*   **Серверная валидация (для пошаговых игр):** Для игр вроде RPG или Дурака логика должна быть строго на сервере (сейчас в RPG и Дураке это частично реализовано, что хорошо).
*   **Rate Limiting:** Жесткое ограничение частоты вызова `add_point` для одного юзера (например, не чаще 1 раза в 10 секунд для кликеров).

### 1.2. Race Conditions (Состояние гонки) при списании баланса
**Проблема:** В `routes.py` (например, метод `api_rpg_buy`) проверка баланса и списание происходят раздельно:
```python
if bal < cost: return error # Чтение
# ... (время идет)
pipe.incrby(key_balance(uid), -cost) # Запись
```
Если отправить два параллельных запроса на покупку предмета, когда денег хватает только на один, оба запроса могут пройти проверку `if bal < cost`, и баланс уйдет в минус (или будет потрачен дважды).

**Решение:**
*   Использовать **Lua-скрипты** в Redis для атомарных операций "проверить и списать".
*   Либо использовать `WATCH/MULTI/EXEC` транзакции Redis.

## 2. Архитектура и Бэкенд

### 2.1. Вложенные функции в `routes.py`
**Проблема:** Все обработчики API (`api_durak_rooms`, `ws_chat` и др.) определены *внутри* функции `register_routes`.
*   **Невозможно тестировать:** Нельзя импортировать `api_add_point` в unit-тест, так как она не находится в глобальной области видимости модуля.
*   **Читаемость:** Файл огромен, навигация затруднена.

**Решение:** Вынести функции-обработчики на уровень модуля (top-level) или разбить на несколько файлов (Routers в FastAPI), а `register_routes` использовать только для `app.include_router()`.

### 2.2. Хранение состояния игр в оперативной памяти
**Проблема:** Класс `DurakManager` хранит состояние комнат в переменной `self.rooms` (Python Dictionary).
*   При перезапуске сервера (который происходит автоматически при `git pull` согласно памяти) **все активные игры прерываются**, а состояние теряется. Игроки теряют ставки.

**Решение:**
*   Сериализовать состояние игр в Redis (JSON или Hash). Это позволит переживать перезапуски процесса API без потери игр.

### 2.3. Отсутствие надежного хранилища (Persistence)
**Проблема:** Все данные (профили, балансы) живут в Redis. Redis — это in-memory store.
*   Если Redis упадет без настроенного AOF/RDB persistence, **все данные пользователей исчезнут**.
*   Нет истории транзакций (ledger). Невозможно разобрать спорные ситуации ("куда делись мои очки?").

**Решение:**
*   Минимум: Убедиться, что Redis настроен с `appendonly yes`.
*   Идеал: Подключить PostgreSQL/SQLite для хранения пользователей и лога транзакций, используя Redis только для кэша и быстрого стейта игр.

## 3. Фронтенд и Оптимизация

### 3.1. Polling (Опрос) в лобби
**Проблема:** В `durak.html` список комнат обновляется через `setInterval` каждые 5 секунд (`loadRooms`).
*   Это создает лишнюю нагрузку на сервер и задержку для пользователя (комната создана, а в списке появится через 4 сек).

**Решение:** Использовать WebSocket не только для игры, но и для лобби (или Server-Sent Events), чтобы мгновенно пушить обновления списка комнат.

### 3.2. Inline JavaScript
**Проблема:** Огромные куски логики (вся игра Doodle Jump, логика Дурака) написаны прямо в `.html` файлах внутри `<script>`.
*   Не работает кэширование браузера для кода.
*   Сложно поддерживать и переиспользовать код.

**Решение:** Вынести JS в отдельные `.js` файлы (например, `ludka/durak.js`, `minigames/doodle.js`).

### 3.3. Отсутствие сборки
**Проблема:** Используется нативный ES-модульный подход или просто скрипты. Нет минификации, нет проверки типов (TypeScript).
*   Файлы весят больше, чем могли бы.

**Решение:** Внедрить Vite или Parcel для сборки фронтенда. Это даст минификацию и возможность использовать TypeScript.

## 4. UX/UI и "Нелогичности"

### 4.1. Обработка ошибок
**Проблема:** Повсеместное использование `alert(e)` или `alert(res.error)`. Это блокирует интерфейс и выглядит непрофессионально в 2024 году.
**Решение:** Использовать "Toast" уведомления (как Telegram native popup или кастомные всплывашки), которые не прерывают flow пользователя.

### 4.2. Хардкод значений
**Проблема:**
*   В коде разбросаны магические числа: `30` (стоимость входа), `100` (приз).
*   В `durak_manager.py` константы вынесены, но на фронтенде в `durak.html` текст "Стоимость: 30 очков" захардкожен. Если изменить цену на сервере, фронтенд будет врать.

**Решение:** Фронтенд должен получать конфиг (цены, лимиты) от сервера при инициализации (`/api/config` или в `init` ответе).

### 4.3. Кнопка "Назад"
**Проблема:** Использование `<a href="/ludka">` перезагружает страницу (SPA-переход был бы быстрее).
**Решение:** Если внедрить простой роутер или перехват кликов, переходы будут мгновенными без моргания экрана.

## 5. Новые идеи (Features)

1.  **Система достижений (Achievements):** Раз уж статистика пишется в Redis, можно легко добавить бейджи ("Сыграл 100 игр", "Выиграл 10 раз подряд"). Это повысит retention.
2.  **Daily Rewards:** Ежедневный бонус за вход, чтобы стимулировать возвращение.
3.  **Global Chat in Lobby:** Добавить чат прямо в лобби поиска игр, чтобы договариваться о партиях.
4.  **Reconnection:** Для Дурака реализовать механизм переподключения (сейчас если WS отвалился, то `disconnect` не удаляет игрока сразу, но фронтенд может не уметь корректно "подхватить" стейт без перезагрузки страницы).

---
**Итог:** Проект работает, но имеет критические уязвимости в экономике (накрутка очков) и архитектурные риски (потеря данных при рестарте). Рекомендуется начать с фикса безопасности (`api_add_point`) и выноса логики API из `register_routes`.
