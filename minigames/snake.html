<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>–ó–º–µ–π–∫–∞ ‚Äî FirstClub</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="/webapp_guard.js"></script>
  <script src="/minigames/snake_logic_adapter.js"></script>
  <style>
    :root{
      --bg:#0a0d12; --bg2:#0e1117; --panel:#0d1117;
      --card:#111722; --card2:#0f1520;
      --stroke:rgba(255,255,255,.06);
      --stroke2:rgba(100,160,255,.25);
      --blue:#3b82f6; --blue2:#1d4ed8;
      --text:#e6edf3; --muted:#98a2b3;
      --green:#22c55e; --red:#ef4444; --amber:#f59e0b;
      --shadow:0 0 0 1px var(--stroke),0 8px 30px rgba(0,0,0,.6);
    }
    html[data-theme="light"]{
      --bg:#f4f7fb; --bg2:#eef2f7; --panel:#ffffff;
      --card:#ffffff; --card2:#f6f8fb;
      --stroke:rgba(10,20,40,.08);
      --stroke2:rgba(59,130,246,.35);
      --blue:#2563eb; --blue2:#1d4ed8;
      --text:#0b1220; --muted:#52607a;
      --shadow:0 0 0 1px var(--stroke),0 10px 26px rgba(10,20,40,.08);
    }
    html,body{height:100%;overflow:hidden;overscroll-behavior:none;-webkit-overflow-scrolling:auto;touch-action:manipulation;}
    *{box-sizing:border-box}
    body{
      margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:var(--text);
      background:radial-gradient(1000px 600px at 10% -10%,rgba(59,130,246,.28),transparent 60%),
        radial-gradient(800px 500px at 110% 0%,rgba(29,78,216,.22),transparent 55%),
        linear-gradient(180deg,var(--bg2) 0%,var(--bg) 100%);
      min-height:100vh;display:flex;justify-content:center;padding:16px;
    }
    .app{width:min(900px,100%);border:1px solid var(--stroke);border-radius:20px;box-shadow:var(--shadow);padding:14px;
      background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,0));height:100%;overflow-y:auto;overscroll-behavior:none;}
    header{display:flex;align-items:center;justify-content:space-between;padding:10px 12px 14px;gap:10px;}
    .title{display:flex;flex-direction:column;gap:2px;align-items:flex-start;}
    .title h1{margin:0;font-size:20px;font-weight:800;}
    .title span{font-size:12px;color:var(--muted);}
    .back{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:10px;
      background:linear-gradient(180deg,var(--card) 0%,var(--card2) 100%);
      border:1px solid var(--stroke);color:var(--text);text-decoration:none;font-weight:700;font-size:14px;
      cursor:pointer;transition:.15s ease;}
    .back:hover{border-color:var(--stroke2);transform:translateY(-1px);}
    .section{background:linear-gradient(180deg,var(--panel) 0%,color-mix(in oklab,var(--panel) 92%,transparent) 100%);
      border:1px solid var(--stroke);border-radius:16px;padding:14px;box-shadow:var(--shadow);margin-bottom:12px;}
    .row{display:flex;align-items:center;gap:10px;flex-wrap:wrap;}
    .pill{padding:8px 12px;border-radius:999px;border:1px solid var(--stroke);background:linear-gradient(180deg,var(--card) 0%,var(--card2) 100%);
      font-weight:800;font-size:13px;display:inline-flex;align-items:center;gap:6px;}
    .btn{padding:10px 16px;border-radius:12px;border:1px solid var(--stroke2);
      background:linear-gradient(180deg,var(--blue) 0%,var(--blue2) 100%);
      color:white;font-weight:900;cursor:pointer;transition:.15s ease;box-shadow:0 6px 18px rgba(37,99,235,.35);}
    .btn.secondary{background:linear-gradient(180deg,var(--card) 0%,var(--card2) 100%);color:var(--text);border-color:var(--stroke);box-shadow:none;}
    .btn:disabled{opacity:.65;cursor:not-allowed;}
    .status{font-size:16px;font-weight:900;margin:8px 0 4px;}
    .status.win{color:var(--green);} .status.lose{color:var(--red);} .status.idle{color:var(--muted);}
    .note{font-size:12px;color:var(--muted);margin:0;line-height:1.5;}
    canvas{width:100%;max-width:520px;aspect-ratio:1/1;border-radius:16px;border:1px solid var(--stroke);background:linear-gradient(180deg,var(--card) 0%,var(--card2) 100%);
      box-shadow:inset 0 0 24px rgba(0,0,0,.4);}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;align-items:center;}
    @media(max-width:700px){.grid{grid-template-columns:1fr;}}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <a class="back" href="/minigames">‚Üê –ù–∞–∑–∞–¥</a>
      <div class="title">
        <h1>–ó–º–µ–π–∫–∞</h1>
        <span>–î–æ—Å—Ç–∏–≥–Ω–∏ –¥–ª–∏–Ω—ã 12+, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –æ—á–∫–æ</span>
      </div>
      <div style="width:64px"></div>
    </header>

    <section class="section" style="display:flex;flex-direction:column;gap:12px;align-items:center;">
      <canvas id="board" width="320" height="320"></canvas>
      <div class="grid" style="width:100%;max-width:520px;">
        <div class="row" style="justify-content:flex-start;">
          <span class="pill">üìè –î–ª–∏–Ω–∞: <span id="length">1</span></span>
          <span class="pill">üéØ –¶–µ–ª—å: 12</span>
          <span class="pill">üçè –°—á—ë—Ç: <span id="score">0</span></span>
        </div>
        <div class="row" style="justify-content:flex-end;">
          <button id="startBtn" class="btn">–ò–≥—Ä–∞—Ç—å</button>
          <button id="restartBtn" class="btn secondary">–°—ã–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
        </div>
      </div>
      <div style="width:100%;max-width:520px;">
        <div id="status" class="status idle">–°–≤–∞–π–ø–Ω–∏ –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π —Å—Ç—Ä–µ–ª–∫–∏ –¥–ª—è —Å–º–µ–Ω—ã –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è.</div>
        <p class="note">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: —Å–≤–∞–π–ø—ã –ø–æ –ø–æ–ª—é (–≤–≤–µ—Ä—Ö/–≤–Ω–∏–∑/–≤–ª–µ–≤–æ/–≤–ø—Ä–∞–≤–æ) –∏–ª–∏ –∫–ª–∞–≤–∏—à–∏ —Å—Ç—Ä–µ–ª–æ–∫. –ù–µ —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–π—Å—è –Ω–∞ 180¬∞ –∑–∞ —Ö–æ–¥. –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ —Å–æ —Å—Ç–µ–Ω–æ–π –∏–ª–∏ —Å–æ–±–æ–π –∑–∞–≤–µ—Ä—à–∏—Ç —Ä–∞—É–Ω–¥.</p>
      </div>
    </section>
  </div>

  <div id="toast" class="toast" style="display:none;"></div>

<script>
  const tgInstance = initTelegramGuard();
  const searchUid = new URLSearchParams(window.location.search).get("uid");
  const TARGET_LENGTH = 12;
  const cellSize = 16;
  const gridSize = 20;
  const board = document.getElementById('board');
  const ctx = board.getContext('2d');
  const statusEl = document.getElementById('status');
  const lengthEl = document.getElementById('length');
  const scoreEl = document.getElementById('score');
  const startBtn = document.getElementById('startBtn');
  const restartBtn = document.getElementById('restartBtn');

  let snake = [];
  let previousSnake = [];
  let dir = {x:1,y:0};
  let nextDir = {x:1,y:0};
  let food = {x:5,y:5};
  let running = false;
  let loopId = null;
  let lastFrameTime = 0;
  let accumulator = 0;
  const stepInterval = 0.12; // seconds between grid steps
  let resultSent = false;

  function api(path, method='GET', body){
    const opts = {method, headers:{'Content-Type':'application/json'}};
    if(body) opts.body = JSON.stringify(body);
    return fetch(path, opts).then(r=>r.json());
  }

  async function apiPost(url, data){
    try{
      const res = await fetch(url,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(data)});
      return await res.json();
    }catch(e){return {ok:false,error:String(e)}}
  }

  function setStatus(text, cls='idle'){
    statusEl.className = 'status '+cls;
    statusEl.textContent = text;
  }

  function resetGame(){
    if(loopId){ cancelAnimationFrame(loopId); loopId=null; }
    snake = [{x:10,y:10}];
    previousSnake = snake.map(s=>({...s}));
    dir = {x:1,y:0};
    nextDir = {x:1,y:0};
    food = SnakeCpp.placeFood(snake, gridSize);
    running = false;
    resultSent = false;
    accumulator = 0;
    lastFrameTime = 0;
    lengthEl.textContent = snake.length;
    scoreEl.textContent = 0;
    setStatus('–ù–∞–∂–º–∏ ¬´–ò–≥—Ä–∞—Ç—å¬ª, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å.', 'idle');
    draw(0);
  }

  function lerp(a,b,t){return a+(b-a)*t;}

  function draw(progress=0){
    ctx.fillStyle = '#0b111b';
    ctx.fillRect(0,0,board.width,board.height);

    // grid lines
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    ctx.lineWidth = 1;
    for(let i=0;i<=gridSize;i++){
      ctx.beginPath();
      ctx.moveTo(i*cellSize+0.5,0);
      ctx.lineTo(i*cellSize+0.5,board.height);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0,i*cellSize+0.5);
      ctx.lineTo(board.width,i*cellSize+0.5);
      ctx.stroke();
    }

    // food
    ctx.save();
    ctx.fillStyle = '#f59e0b';
    ctx.shadowColor = 'rgba(245,158,11,0.6)';
    ctx.shadowBlur = 10;
    ctx.fillRect(food.x*cellSize+2, food.y*cellSize+2, cellSize-4, cellSize-4);
    ctx.restore();

    const points = snake.map((segment, idx)=>{
      const prev = previousSnake[idx] || segment;
      return {
        x: lerp(prev.x, segment.x, progress) * cellSize + cellSize/2,
        y: lerp(prev.y, segment.y, progress) * cellSize + cellSize/2
      };
    });

    if(points.length){
      const head = points[0];
      const tail = points[points.length-1];
      const bodyGradient = ctx.createLinearGradient(head.x, head.y, tail.x, tail.y);
      bodyGradient.addColorStop(0, '#34d399');
      bodyGradient.addColorStop(1, '#1d4ed8');

      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.strokeStyle = bodyGradient;
      ctx.lineWidth = cellSize * 0.9;
      ctx.shadowColor = 'rgba(52,211,153,0.35)';
      ctx.shadowBlur = 10;

      ctx.beginPath();
      ctx.moveTo(head.x, head.y);
      if(points.length > 1){
        for(let i=1;i<points.length;i++){
          ctx.lineTo(points[i].x, points[i].y);
        }
      } else {
        ctx.lineTo(head.x, head.y);
      }
      ctx.stroke();

      ctx.shadowBlur = 0;
      ctx.fillStyle = '#0b0f14';
      const eyeOffset = cellSize * 0.2;
      ctx.beginPath();
      ctx.arc(head.x + eyeOffset, head.y - eyeOffset/1.1, 3, 0, Math.PI*2);
      ctx.arc(head.x + eyeOffset, head.y + eyeOffset/1.1, 3, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function step(){
    previousSnake = snake.map(s=>({...s}));
    dir = {...nextDir};
    const result = SnakeCpp.snakeStepCpp(snake, dir, food, gridSize);
    if(result.dead){
      endGame('loss','–°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑!');
      return;
    }

    snake = result.snake.map(s=>({...s}));
    food = {...result.food};
    if(result.ate){
      scoreEl.textContent = Number(scoreEl.textContent) + 1;
      if(snake.length >= TARGET_LENGTH){
        endGame('win','–ü–æ–±–µ–¥–∞! +1 –æ—á–∫–æ –∑–∞ –¥–ª–∏–Ω—É –∑–º–µ–π–∫–∏.');
        return;
      }
    }

    lengthEl.textContent = snake.length;
    draw();
  }

  function endGame(result, message){
    if(loopId){ cancelAnimationFrame(loopId); loopId=null; }
    running = false;
    setStatus(message, result==='win' ? 'win' : 'lose');
    reportResult(result);
  }

  function startLoop(){
    if(loopId) cancelAnimationFrame(loopId);
    accumulator = 0;
    lastFrameTime = 0;
    const loop = (timestamp)=>{
      if(!lastFrameTime) lastFrameTime = timestamp;
      const delta = Math.min(0.05, (timestamp - lastFrameTime)/1000);
      lastFrameTime = timestamp;
      accumulator += delta;
      while(running && accumulator >= stepInterval){
        step();
        accumulator -= stepInterval;
      }
      const progress = Math.min(accumulator / stepInterval, 1);
      draw(progress);
      if(running){ loopId = requestAnimationFrame(loop); }
    };
    loopId = requestAnimationFrame(loop);
  }

  function handleDirection(nx, ny){
    if(running){
      if(dir.x === -nx && dir.y === -ny) return; // no 180
      nextDir = {x:nx,y:ny};
    }
  }

  async function reportResult(result){
    if(resultSent) return;
    resultSent = true;
    const uid = tg?.initDataUnsafe?.user?.id || searchUid;
    if(!uid) return;
    await apiPost('/api/report_game', {user_id:String(uid), game:'snake', result});
    if(result === 'win'){
      await apiPost('/api/add_point', {user_id:String(uid), game:'snake', delta:1});
    }
  }

  startBtn.addEventListener('click', ()=>{
    resetGame();
    running = true;
    setStatus('–ò–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å! –°–æ–±–∏—Ä–∞–π –µ–¥—É –∏ –Ω–µ —Å—Ç–∞–ª–∫–∏–≤–∞–π—Å—è.', '');
    startLoop();
  });

  restartBtn.addEventListener('click', ()=>{
    resetGame();
  });

  document.addEventListener('keydown', (e)=>{
    if(['ArrowUp','KeyW'].includes(e.code)) handleDirection(0,-1);
    if(['ArrowDown','KeyS'].includes(e.code)) handleDirection(0,1);
    if(['ArrowLeft','KeyA'].includes(e.code)) handleDirection(-1,0);
    if(['ArrowRight','KeyD'].includes(e.code)) handleDirection(1,0);
  });

  let touchStart = null;
  board.addEventListener('touchstart', (e)=>{
    const t = e.touches[0];
    touchStart = {x:t.clientX, y:t.clientY};
  });
  board.addEventListener('touchend', (e)=>{
    if(!touchStart) return;
    const t = e.changedTouches[0];
    const dx = t.clientX - touchStart.x;
    const dy = t.clientY - touchStart.y;
    const absX = Math.abs(dx), absY=Math.abs(dy);
    if(Math.max(absX, absY) < 20) return;
    if(absX > absY){
      handleDirection(dx>0?1:-1,0);
    }else{
      handleDirection(0, dy>0?1:-1);
    }
    touchStart=null;
  });

  resetGame();

  (async()=>{
    if(!tgInstance) return;
    await ensureNicknameOrRedirect();
  })();
</script>
</body>
</html>
