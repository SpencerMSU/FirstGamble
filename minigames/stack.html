<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>City Bloxx — FirstClub</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="/webapp_guard.js"></script>
  <style>
    :root{
      --bg:#0a0d12; --bg2:#0e1117; --panel:#0d1117;
      --card:#111722; --card2:#0f1520;
      --stroke:rgba(255,255,255,.06); --stroke2:rgba(100,160,255,.25);
      --blue:#3b82f6; --blue2:#1d4ed8;
      --text:#e6edf3; --muted:#98a2b3;
      --green:#22c55e; --red:#ef4444; --amber:#f59e0b;
      --shadow:0 0 0 1px var(--stroke),0 8px 30px rgba(0,0,0,.6);
    }
    html[data-theme="light"]{
      --bg:#f4f7fb; --bg2:#eef2f7; --panel:#ffffff;
      --card:#ffffff; --card2:#f6f8fb;
      --stroke:rgba(10,20,40,.08); --stroke2:rgba(59,130,246,.35);
      --blue:#2563eb; --blue2:#1d4ed8;
      --text:#0b1220; --muted:#52607a;
      --shadow:0 0 0 1px var(--stroke),0 10px 26px rgba(10,20,40,.08);
    }
    html,body{height:100%;overflow:hidden;overscroll-behavior:none;-webkit-overflow-scrolling:auto;touch-action:manipulation;}
    *{box-sizing:border-box}
    body{
      margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:var(--text);
      background:linear-gradient(180deg,var(--bg2) 0%,var(--bg) 100%);
      min-height:100vh;display:flex;justify-content:center;padding:16px;
    }
    .app{width:min(900px,100%);border:1px solid var(--stroke);border-radius:20px;box-shadow:var(--shadow);padding:14px;
      background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,0));height:100%;overflow-y:auto;overscroll-behavior:none;
      display:flex;flex-direction:column;gap:12px;}
    header{display:flex;align-items:center;justify-content:space-between;padding:10px 12px 14px;gap:10px;}
    .title{display:flex;flex-direction:column;gap:2px;align-items:flex-start;}
    .title h1{margin:0;font-size:20px;font-weight:800;}
    .title span{font-size:12px;color:var(--muted);}
    .back{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:10px;
      background:linear-gradient(180deg,var(--card) 0%,var(--card2) 100%);
      border:1px solid var(--stroke);color:var(--text);text-decoration:none;font-weight:700;font-size:14px;
      cursor:pointer;transition:.15s ease;}
    .back:hover{border-color:var(--stroke2);transform:translateY(-1px);}

    .game-area{
      flex:1;position:relative;background:var(--panel);border-radius:16px;border:1px solid var(--stroke);
      overflow:hidden;touch-action:none;cursor:pointer;
    }
    canvas{display:block;width:100%;height:100%;}

    .overlay{position:absolute;top:0;left:0;width:100%;height:100%;display:flex;flex-direction:column;
      align-items:center;justify-content:center;background:rgba(0,0,0,0.6);backdrop-filter:blur(4px);
      transition:opacity 0.3s ease;z-index:10;}
    .overlay.hidden{opacity:0;pointer-events:none;}
    .overlay h2{font-size:32px;margin:0 0 16px;color:white;text-shadow:0 2px 10px rgba(0,0,0,0.5);}
    .btn{padding:12px 24px;border-radius:12px;border:1px solid rgba(255,255,255,0.2);
      background:linear-gradient(180deg,var(--blue) 0%,var(--blue2) 100%);
      color:white;font-weight:800;font-size:18px;cursor:pointer;transition:.2s ease;
      box-shadow:0 4px 12px rgba(37,99,235,0.4);}
    .btn:active{transform:scale(0.96);}

    .score-hud{position:absolute;top:16px;left:50%;transform:translateX(-50%);font-size:48px;font-weight:900;
      color:white;text-shadow:0 4px 12px rgba(0,0,0,0.5);pointer-events:none;z-index:5;}
    .best-score{position:absolute;top:16px;right:16px;font-size:14px;color:var(--muted);font-weight:700;
      background:rgba(0,0,0,0.4);padding:4px 8px;border-radius:6px;pointer-events:none;z-index:5;}

  </style>
</head>
<body>
  <div class="app">
    <header>
      <a class="back" href="/minigames">← Назад</a>
      <div class="title">
        <h1>City Bloxx</h1>
        <span>Строй выше облаков!</span>
      </div>
      <div style="width:64px"></div>
    </header>

    <div class="game-area" id="gameContainer">
      <div class="best-score">Рекорд: <span id="bestVal">0</span></div>
      <div class="score-hud" id="scoreVal">0</div>
      <canvas id="gameCanvas"></canvas>
      <div class="overlay" id="startScreen">
        <h2>City Bloxx</h2>
        <button class="btn" id="startBtn">Играть</button>
      </div>
      <div class="overlay hidden" id="endScreen">
        <h2 id="endTitle">Игра окончена</h2>
        <div style="font-size:18px;color:#cbd5e1;margin-bottom:20px;">Счет: <span id="finalScore">0</span></div>
        <button class="btn" id="restartBtn">Ещё раз</button>
      </div>
    </div>
  </div>

<script>
  const tgInstance = initTelegramGuard();
  const searchUid = new URLSearchParams(window.location.search).get('uid');

  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const startScreen = document.getElementById('startScreen');
  const endScreen = document.getElementById('endScreen');
  const scoreVal = document.getElementById('scoreVal');
  const bestVal = document.getElementById('bestVal');
  const finalScore = document.getElementById('finalScore');
  const endTitle = document.getElementById('endTitle');

  // Game config
  const BLOCK_H = 30; // height of block
  const BLOCK_START_W = 200; // starting width

  let width, height;
  let blocks = [];
  let currentBlock = null;
  let score = 0;
  let best = Number(localStorage.getItem('stack_best')||0);
  bestVal.textContent = best;
  let state = 'menu'; // menu, playing, gameover
  let cameraY = 0;
  let hue = 0;
  let speed = 4;
  let direction = 1; // 1 or -1
  let resultSent = false;
  let bonusGiven = false;

  function resize(){
    width = canvas.parentElement.clientWidth;
    height = canvas.parentElement.clientHeight;
    canvas.width = width * window.devicePixelRatio;
    canvas.height = height * window.devicePixelRatio;
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    width = width; // logical width
    height = height;
  }
  window.addEventListener('resize', resize);
  resize();

  function drawBlock(b){
    const {x, y, w, color} = b;
    // 2D simple rect
    // Centered relative to width/2
    // Screen coords: x is offset from center
    // We'll treat b.x as center offset? Or left edge?
    // Let's use b.x as the Left edge relative to screen left for 2D simplicity.

    // Actually, to keep it centered like the old phone game:
    // Screen Center = width/2.
    // We map logical coordinate system to screen.
    // Let's just use raw screen coordinates for X.

    const screenY = height - (y - cameraY) - BLOCK_H - 50; // 50 padding bottom

    ctx.fillStyle = color;
    ctx.fillRect(x, screenY, w, BLOCK_H);

    // Highlight
    ctx.fillStyle = "rgba(255,255,255,0.2)";
    ctx.fillRect(x, screenY, w, 4);

    // Border
    ctx.strokeStyle = "rgba(0,0,0,0.2)";
    ctx.lineWidth = 1;
    ctx.strokeRect(x, screenY, w, BLOCK_H);
  }

  function adjustColor(hex, percent) {
    // Simple hex darken
    let num = parseInt(hex.replace("#",""),16),
    amt = Math.round(2.55 * percent),
    R = (num >> 16) + amt,
    G = (num >> 8 & 0x00FF) + amt,
    B = (num & 0x0000FF) + amt;
    return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1);
  }

  function initGame(){
    blocks = [];
    score = 0;
    cameraY = 0;
    hue = Math.random() * 360;
    speed = 3.5;
    resultSent = false;

    // Base block centered
    // width/2 - BLOCK_START_W/2
    blocks.push({
      x: width/2 - BLOCK_START_W/2,
      y: 0,
      w: BLOCK_START_W,
      color: `hsl(${hue}, 70%, 50%)`
    });

    spawnNext();
    scoreVal.textContent = "0";
    state = 'playing';
    startScreen.classList.add('hidden');
    endScreen.classList.add('hidden');
    loop();
  }

  function spawnNext(){
    const prev = blocks[blocks.length-1];
    score = blocks.length - 1;
    scoreVal.textContent = score;
    hue += 10;
    direction = Math.random() > 0.5 ? 1 : -1;

    // Start off-screen
    // If direction 1 (left to right), start at -w
    // If direction -1 (right to left), start at width
    let nx = direction === 1 ? -prev.w : width;

    currentBlock = {
      x: nx,
      y: (score+1) * BLOCK_H,
      w: prev.w,
      color: `hsl(${hue}, 70%, 50%)`
    };

    speed = 4 + score * 0.1;
    if(speed > 12) speed = 12;
  }

  function gameOver(){
    state = 'gameover';
    if(score > best){
      best = score;
      localStorage.setItem('stack_best', best);
      bestVal.textContent = best;
    }
    finalScore.textContent = score;

    const win = score >= 20;
    endTitle.textContent = win ? "Победа! (+1 балл)" : "Игра окончена";
    endTitle.style.color = win ? "#4ade80" : "#ffffff";

    endScreen.classList.remove('hidden');

    // Report
    if(!resultSent){
      resultSent = true;
      const res = win ? 'win' : 'loss';
      const uid = tg?.initDataUnsafe?.user?.id || searchUid;
      if(uid){
         fetch('/api/report_game',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({user_id:String(uid), game:'stack', result:res})});

         // 2 points per floor logic:
         // We can send total points at end?
         // Request says: "За каждый построенный этаж в башне даеться 2 очка"
         // If we send it incrementally, it's safer against crash but spams API.
         // If we send at end, we calculate total.
         // Let's send at end. score = floors built.
         if(score > 0){
             fetch('/api/add_point',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({user_id:String(uid), game:'stack', delta: score * 2})});
         }
      }
    }
  }

  function placeBlock(){
    if(state !== 'playing') return;

    const prev = blocks[blocks.length-1];
    const curr = currentBlock;

    let bonus = false;

    // Check overlap on X
    let dist = curr.x - prev.x;
    // Perfect snap tolerance
    if(Math.abs(dist) < 3) {
      dist = 0;
      curr.x = prev.x;
      bonus = true;
    }

    if(dist > 0){
      // Block is to the right of prev
      // Overlap = prev.x + prev.w - curr.x
      // Since curr.x = prev.x + dist
      // Overlap = prev.w - dist
      const overlap = prev.w - dist;
      if(overlap <= 0) return gameOver();
      curr.w = overlap;
      // curr.x remains same
    } else {
      // Block is to the left of prev (dist is negative)
      // curr.x = prev.x + dist (e.g. prev=100, dist=-10 => curr=90)
      // Overlap = curr.x + curr.w - prev.x
      //         = (prev.x + dist) + prev.w - prev.x
      //         = prev.w + dist
      const overlap = prev.w + dist;
      if(overlap <= 0) return gameOver();
      curr.w = overlap;
      curr.x = prev.x; // Trim from left side means we shift x to match prev x
    }

    blocks.push(curr);
    spawnNext();
  }

  function loop(){
    if(state !== 'playing' && state !== 'gameover') return;

    ctx.clearRect(0,0,width,height);

    // Update logic
    if(state === 'playing'){
      currentBlock.x += speed * direction;

      // Ping pong
      // If goes off screen too far, reverse?
      // Standard stacker just bounces off walls or reverses at arbitrary point.
      // Let's reverse if it clears the stack completely + margin
      // stack width is variable.
      // Let's just limit to screen width bounds roughly?
      if(currentBlock.x > width - 20) direction = -1;
      if(currentBlock.x < -currentBlock.w + 20) direction = 1;

      // Target camera to center the stack top vertically
      // We want the top block to be around 1/3 from bottom or so?
      // Actually standard stacker: camera moves up as we build.
      // block y increases by BLOCK_H.
      // cameraY should track it.
      // drawBlock uses: screenY = height - (y - cameraY) - ...
      // If y increases, screenY decreases (goes up).
      // We want screenY to stay roughly constant (e.g. 200px from bottom).
      // height - (y - cameraY) ~ 200
      // y - cameraY ~ height - 200
      // cameraY ~ y - height + 200
      let targetCam = currentBlock.y - height * 0.4;
      if(targetCam < 0) targetCam = 0;

      cameraY += (targetCam - cameraY) * 0.1;
    }

    // Draw
    blocks.forEach(drawBlock);
    if(currentBlock && state === 'playing') drawBlock(currentBlock);

    // Overlay instructions if playing
    if(state === 'playing'){
      ctx.fillStyle = "rgba(255,255,255,0.7)";
      ctx.font = "14px system-ui";
      ctx.textAlign = "center";
      ctx.fillText("ПК: Пробел | Телефон: Тап", width/2, height - 20);
    }

    if(state === 'playing' || state === 'gameover'){
      requestAnimationFrame(loop);
    }
  }

  // Input
  document.getElementById('startBtn').addEventListener('click', initGame);
  document.getElementById('restartBtn').addEventListener('click', initGame);

  // Use pointerdown on container for taps
  const gameArea = document.getElementById('gameContainer');
  gameArea.addEventListener('pointerdown', (e)=>{
    if(e.target.tagName === 'BUTTON') return;
    if(state === 'playing'){
      placeBlock();
      e.preventDefault(); // prevent zoom etc
    }
  });

  // Spacebar
  document.addEventListener('keydown', (e)=>{
    if(e.code === 'Space' && state === 'playing'){
      placeBlock();
      e.preventDefault(); // Prevent scrolling
    }
  });

  (async()=>{
    if(!tgInstance) return;
    await ensureNicknameOrRedirect();
  })();

</script>
</body>
</html>
