<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Башня — FirstClub</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="/webapp_guard.js"></script>
  <style>
    :root{
      --bg:#0a0d12; --bg2:#0e1117; --panel:#0d1117;
      --card:#111722; --card2:#0f1520;
      --stroke:rgba(255,255,255,.06); --stroke2:rgba(100,160,255,.25);
      --blue:#3b82f6; --blue2:#1d4ed8;
      --text:#e6edf3; --muted:#98a2b3;
      --green:#22c55e; --red:#ef4444; --amber:#f59e0b;
      --shadow:0 0 0 1px var(--stroke),0 8px 30px rgba(0,0,0,.6);
    }
    html[data-theme="light"]{
      --bg:#f4f7fb; --bg2:#eef2f7; --panel:#ffffff;
      --card:#ffffff; --card2:#f6f8fb;
      --stroke:rgba(10,20,40,.08); --stroke2:rgba(59,130,246,.35);
      --blue:#2563eb; --blue2:#1d4ed8;
      --text:#0b1220; --muted:#52607a;
      --shadow:0 0 0 1px var(--stroke),0 10px 26px rgba(10,20,40,.08);
    }
    html,body{height:100%;overflow:hidden;overscroll-behavior:none;-webkit-overflow-scrolling:auto;touch-action:manipulation;}
    *{box-sizing:border-box}
    body{
      margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:var(--text);
      background:linear-gradient(180deg,var(--bg2) 0%,var(--bg) 100%);
      min-height:100vh;display:flex;justify-content:center;padding:16px;
    }
    .app{width:min(900px,100%);border:1px solid var(--stroke);border-radius:20px;box-shadow:var(--shadow);padding:14px;
      background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,0));height:100%;overflow-y:auto;overscroll-behavior:none;
      display:flex;flex-direction:column;gap:12px;}
    header{display:flex;align-items:center;justify-content:space-between;padding:10px 12px 14px;gap:10px;}
    .title{display:flex;flex-direction:column;gap:2px;align-items:flex-start;}
    .title h1{margin:0;font-size:20px;font-weight:800;}
    .title span{font-size:12px;color:var(--muted);}
    .back{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:10px;
      background:linear-gradient(180deg,var(--card) 0%,var(--card2) 100%);
      border:1px solid var(--stroke);color:var(--text);text-decoration:none;font-weight:700;font-size:14px;
      cursor:pointer;transition:.15s ease;}
    .back:hover{border-color:var(--stroke2);transform:translateY(-1px);}

    .game-area{
      flex:1;position:relative;background:var(--panel);border-radius:16px;border:1px solid var(--stroke);
      overflow:hidden;touch-action:none;cursor:pointer;
    }
    canvas{display:block;width:100%;height:100%;}

    .overlay{position:absolute;top:0;left:0;width:100%;height:100%;display:flex;flex-direction:column;
      align-items:center;justify-content:center;background:rgba(0,0,0,0.6);backdrop-filter:blur(4px);
      transition:opacity 0.3s ease;z-index:10;}
    .overlay.hidden{opacity:0;pointer-events:none;}
    .overlay h2{font-size:32px;margin:0 0 16px;color:white;text-shadow:0 2px 10px rgba(0,0,0,0.5);}
    .btn{padding:12px 24px;border-radius:12px;border:1px solid rgba(255,255,255,0.2);
      background:linear-gradient(180deg,var(--blue) 0%,var(--blue2) 100%);
      color:white;font-weight:800;font-size:18px;cursor:pointer;transition:.2s ease;
      box-shadow:0 4px 12px rgba(37,99,235,0.4);}
    .btn:active{transform:scale(0.96);}

    .score-hud{position:absolute;top:16px;left:50%;transform:translateX(-50%);font-size:48px;font-weight:900;
      color:white;text-shadow:0 4px 12px rgba(0,0,0,0.5);pointer-events:none;z-index:5;}
    .best-score{position:absolute;top:16px;right:16px;font-size:14px;color:var(--muted);font-weight:700;
      background:rgba(0,0,0,0.4);padding:4px 8px;border-radius:6px;pointer-events:none;z-index:5;}

  </style>
</head>
<body>
  <div class="app">
    <header>
      <a class="back" href="/minigames">← Назад</a>
      <div class="title">
        <h1>Башня</h1>
        <span>Строй выше облаков!</span>
      </div>
      <div style="width:64px"></div>
    </header>

    <div class="game-area" id="gameContainer">
      <div class="best-score">Рекорд: <span id="bestVal">0</span></div>
      <div class="score-hud" id="scoreVal">0</div>
      <canvas id="gameCanvas"></canvas>
      <div class="overlay" id="startScreen">
        <h2>Башня</h2>
        <button class="btn" id="startBtn">Играть</button>
      </div>
      <div class="overlay hidden" id="endScreen">
        <h2 id="endTitle">Игра окончена</h2>
        <div style="font-size:18px;color:#cbd5e1;margin-bottom:20px;">Счет: <span id="finalScore">0</span></div>
        <button class="btn" id="restartBtn">Ещё раз</button>
      </div>
    </div>
  </div>

<script>
  const tgInstance = initTelegramGuard();
  const searchUid = new URLSearchParams(window.location.search).get('uid');

  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const startScreen = document.getElementById('startScreen');
  const endScreen = document.getElementById('endScreen');
  const scoreVal = document.getElementById('scoreVal');
  const bestVal = document.getElementById('bestVal');
  const finalScore = document.getElementById('finalScore');
  const endTitle = document.getElementById('endTitle');

  // Game config
  const ISO_ANGLE = 0.5; // radians for isometric skew roughly
  const BLOCK_H = 20; // visual height of block side
  const LAYER_H = 30; // height step per layer

  let width, height;
  let blocks = [];
  let currentBlock = null;
  let score = 0;
  let best = Number(localStorage.getItem('stack_best')||0);
  bestVal.textContent = best;
  let state = 'menu'; // menu, playing, gameover
  let cameraY = 0;
  let hue = 0;
  let speed = 2;
  let direction = 1; // 1 or -1
  let axis = 'x'; // 'x' or 'z'
  let resultSent = false;

  function resize(){
    width = canvas.parentElement.clientWidth;
    height = canvas.parentElement.clientHeight;
    canvas.width = width * window.devicePixelRatio;
    canvas.height = height * window.devicePixelRatio;
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    width = width; // logical width
    height = height;
  }
  window.addEventListener('resize', resize);
  resize();

  // Isometric projection helper
  function toIso(x, y, z){
    return {
      x: width/2 + (x - z) * Math.cos(ISO_ANGLE) * 1.5,
      y: height/1.5 + (x + z) * Math.sin(ISO_ANGLE) - y * 1.0 + cameraY
    };
  }

  function drawBlock(b){
    const {x, y, z, w, d, color} = b;

    // Top face
    const p1 = toIso(x, y, z);
    const p2 = toIso(x+w, y, z);
    const p3 = toIso(x+w, y, z+d);
    const p4 = toIso(x, y, z+d);

    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.lineTo(p3.x, p3.y);
    ctx.lineTo(p4.x, p4.y);
    ctx.closePath();
    ctx.fill();
    // Highlight edges
    ctx.strokeStyle = "rgba(255,255,255,0.2)";
    ctx.lineWidth = 1;
    ctx.stroke();

    // Right face (visible if viewed from front-right)
    const p2b = {x: p2.x, y: p2.y + BLOCK_H};
    const p3b = {x: p3.x, y: p3.y + BLOCK_H};

    ctx.fillStyle = adjustColor(color, -20);
    ctx.beginPath();
    ctx.moveTo(p2.x, p2.y);
    ctx.lineTo(p3.x, p3.y);
    ctx.lineTo(p3b.x, p3b.y);
    ctx.lineTo(p2b.x, p2b.y);
    ctx.closePath();
    ctx.fill();

    // Left face
    const p3c = {x: p3.x, y: p3.y + BLOCK_H};
    const p4c = {x: p4.x, y: p4.y + BLOCK_H};

    ctx.fillStyle = adjustColor(color, -40);
    ctx.beginPath();
    ctx.moveTo(p3.x, p3.y);
    ctx.lineTo(p4.x, p4.y);
    ctx.lineTo(p4c.x, p4c.y);
    ctx.lineTo(p3c.x, p3c.y);
    ctx.closePath();
    ctx.fill();
  }

  function adjustColor(hex, percent) {
    // Simple hex darken
    let num = parseInt(hex.replace("#",""),16),
    amt = Math.round(2.55 * percent),
    R = (num >> 16) + amt,
    G = (num >> 8 & 0x00FF) + amt,
    B = (num & 0x0000FF) + amt;
    return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1);
  }

  function initGame(){
    blocks = [];
    score = 0;
    cameraY = 0;
    hue = Math.random() * 360;
    speed = 2.5;
    resultSent = false;

    // Base block
    blocks.push({
      x: -50, z: -50, y: 0, w: 100, d: 100,
      color: `hsl(${hue}, 70%, 50%)`
    });

    spawnNext();
    scoreVal.textContent = "0";
    state = 'playing';
    startScreen.classList.add('hidden');
    endScreen.classList.add('hidden');
    loop();
  }

  function spawnNext(){
    const prev = blocks[blocks.length-1];
    score = blocks.length - 1;
    scoreVal.textContent = score;
    hue += 10;

    axis = (score % 2 === 0) ? 'x' : 'z';
    direction = -1; // always come from one side initially

    // Starting pos
    let nx = prev.x;
    let nz = prev.z;
    let startDist = 120 + score*2;

    if(axis === 'x'){
      nx -= startDist;
    } else {
      nz -= startDist;
    }

    currentBlock = {
      x: nx,
      z: nz,
      y: (score+1) * LAYER_H,
      w: prev.w,
      d: prev.d,
      color: `hsl(${hue}, 70%, 50%)`
    };

    speed = 2.5 + score * 0.1;
    if(speed > 6) speed = 6;
  }

  function gameOver(){
    state = 'gameover';
    if(score > best){
      best = score;
      localStorage.setItem('stack_best', best);
      bestVal.textContent = best;
    }
    finalScore.textContent = score;

    const win = score >= 20;
    endTitle.textContent = win ? "Победа! (+1 балл)" : "Игра окончена";
    endTitle.style.color = win ? "#4ade80" : "#ffffff";

    endScreen.classList.remove('hidden');

    // Report
    if(!resultSent){
      resultSent = true;
      const res = win ? 'win' : 'loss';
      const uid = tg?.initDataUnsafe?.user?.id || searchUid;
      if(uid){
         fetch('/api/report_game',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({user_id:String(uid), game:'stack', result:res})});
         if(win){
           fetch('/api/add_point',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({user_id:String(uid), game:'stack', delta:1})});
         }
      }
    }
  }

  function placeBlock(){
    if(state !== 'playing') return;

    const prev = blocks[blocks.length-1];
    const curr = currentBlock;

    let cut = 0;
    let overlap = 0;
    let bonus = false;

    if(axis === 'x'){
      let dist = curr.x - prev.x;
      if(Math.abs(dist) < 2) { dist = 0; curr.x = prev.x; bonus = true; } // perfect snap

      if(dist > 0){
        // moved too far positive x
        overlap = prev.w - dist;
        if(overlap <= 0) return gameOver(); // miss
        curr.w = overlap;
        // cut off part logic? visual only needed if physics.
        // x stays same? No, x needs to shift if we cropped left?
        // Actually: if prev at 0, w=100. curr at 10. overlap=90. curr should start at 10, width 90. Correct.
      } else {
        // negative x
        overlap = prev.w + dist;
        if(overlap <= 0) return gameOver();
        curr.w = overlap;
        curr.x = prev.x; // shift to align with previous left edge
      }
    } else {
      // z axis
      let dist = curr.z - prev.z;
      if(Math.abs(dist) < 2) { dist = 0; curr.z = prev.z; bonus = true; }

      if(dist > 0){
        overlap = prev.d - dist;
        if(overlap <= 0) return gameOver();
        curr.d = overlap;
      } else {
        overlap = prev.d + dist;
        if(overlap <= 0) return gameOver();
        curr.d = overlap;
        curr.z = prev.z;
      }
    }

    blocks.push(curr);
    spawnNext();
  }

  function loop(){
    if(state !== 'playing' && state !== 'gameover') return;

    ctx.clearRect(0,0,width,height);

    // Update logic
    if(state === 'playing'){
      // Move current block
      let range = 180;
      if(axis === 'x'){
        currentBlock.x += speed * direction;
        // bounce logic not needed, just fly through and if miss loop back?
        // User wants "stacker", usually it bounces back and forth.
        const prev = blocks[blocks.length-1];
        if(currentBlock.x > prev.x + 150) direction = -1;
        if(currentBlock.x < prev.x - 150) direction = 1;
      } else {
        currentBlock.z += speed * direction;
        const prev = blocks[blocks.length-1];
        if(currentBlock.z > prev.z + 150) direction = -1;
        if(currentBlock.z < prev.z - 150) direction = 1;
      }

      // Target camera
      let targetY = -(currentBlock.y - 150);
      cameraY += (targetY - cameraY) * 0.1;
    }

    // Draw
    blocks.forEach(drawBlock);
    if(currentBlock && state === 'playing') drawBlock(currentBlock);

    if(state === 'playing' || state === 'gameover'){
      requestAnimationFrame(loop);
    }
  }

  // Input
  document.getElementById('startBtn').addEventListener('click', initGame);
  document.getElementById('restartBtn').addEventListener('click', initGame);
  document.getElementById('gameContainer').addEventListener('pointerdown', (e)=>{
    if(e.target.tagName === 'BUTTON') return;
    if(state === 'playing'){
      placeBlock();
    }
  });

  // Spacebar
  document.addEventListener('keydown', (e)=>{
    if(e.code === 'Space' && state === 'playing'){
      placeBlock();
    }
  });

  (async()=>{
    if(!tgInstance) return;
    await ensureNicknameOrRedirect();
  })();

</script>
</body>
</html>
