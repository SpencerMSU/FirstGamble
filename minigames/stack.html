<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>City Bloxx — FirstClub</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="/webapp_guard.js"></script>
  <style>
    :root{
      --bg:#0a0d12; --bg2:#0e1117; --panel:#0d1117;
      --card:#111722; --card2:#0f1520;
      --stroke:rgba(255,255,255,.06); --stroke2:rgba(100,160,255,.25);
      --blue:#3b82f6; --blue2:#1d4ed8;
      --text:#e6edf3; --muted:#98a2b3;
      --green:#22c55e; --red:#ef4444; --amber:#f59e0b;
      --shadow:0 0 0 1px var(--stroke),0 8px 30px rgba(0,0,0,.6);
    }
    html[data-theme="light"]{
      --bg:#f4f7fb; --bg2:#eef2f7; --panel:#ffffff;
      --card:#ffffff; --card2:#f6f8fb;
      --stroke:rgba(10,20,40,.08); --stroke2:rgba(59,130,246,.35);
      --blue:#2563eb; --blue2:#1d4ed8;
      --text:#0b1220; --muted:#52607a;
      --shadow:0 0 0 1px var(--stroke),0 10px 26px rgba(10,20,40,.08);
    }
    html,body{height:100%;overflow:hidden;overscroll-behavior:none;-webkit-overflow-scrolling:auto;touch-action:manipulation;}
    *{box-sizing:border-box}
    body{
      margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:var(--text);
      background:linear-gradient(180deg,var(--bg2) 0%,var(--bg) 100%);
      min-height:100vh;display:flex;justify-content:center;padding:16px;
    }
    .app{width:min(900px,100%);border:1px solid var(--stroke);border-radius:20px;box-shadow:var(--shadow);padding:14px;
      background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,0));height:100%;overflow-y:auto;overscroll-behavior:none;
      display:flex;flex-direction:column;gap:12px;}
    header{display:flex;align-items:center;justify-content:space-between;padding:10px 12px 14px;gap:10px;}
    .title{display:flex;flex-direction:column;gap:2px;align-items:flex-start;}
    .title h1{margin:0;font-size:20px;font-weight:800;}
    .title span{font-size:12px;color:var(--muted);}
    .back{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:10px;
      background:linear-gradient(180deg,var(--card) 0%,var(--card2) 100%);
      border:1px solid var(--stroke);color:var(--text);text-decoration:none;font-weight:700;font-size:14px;
      cursor:pointer;transition:.15s ease;}
    .back:hover{border-color:var(--stroke2);transform:translateY(-1px);}

    .game-area{
      flex:1;position:relative;background:var(--panel);border-radius:16px;border:1px solid var(--stroke);
      overflow:hidden;touch-action:none;cursor:pointer;
    }
    canvas{display:block;width:100%;height:100%;}

    .overlay{position:absolute;top:0;left:0;width:100%;height:100%;display:flex;flex-direction:column;
      align-items:center;justify-content:center;background:rgba(0,0,0,0.6);backdrop-filter:blur(4px);
      transition:opacity 0.3s ease;z-index:10;}
    .overlay.hidden{opacity:0;pointer-events:none;}
    .overlay h2{font-size:32px;margin:0 0 16px;color:white;text-shadow:0 2px 10px rgba(0,0,0,0.5);}
    .btn{padding:12px 24px;border-radius:12px;border:1px solid rgba(255,255,255,0.2);
      background:linear-gradient(180deg,var(--blue) 0%,var(--blue2) 100%);
      color:white;font-weight:800;font-size:18px;cursor:pointer;transition:.2s ease;
      box-shadow:0 4px 12px rgba(37,99,235,0.4);}
    .btn:active{transform:scale(0.96);}

    .score-hud{position:absolute;top:16px;left:50%;transform:translateX(-50%);font-size:48px;font-weight:900;
      color:white;text-shadow:0 4px 12px rgba(0,0,0,0.5);pointer-events:none;z-index:5;}
    .best-score{position:absolute;top:16px;right:16px;font-size:14px;color:var(--muted);font-weight:700;
      background:rgba(0,0,0,0.4);padding:4px 8px;border-radius:6px;pointer-events:none;z-index:5;}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <a class="back" href="/minigames">← Назад</a>
      <div class="title">
        <h1>City Bloxx</h1>
        <span>Строй выше облаков!</span>
      </div>
      <div style="width:64px"></div>
    </header>

    <div class="game-area" id="gameContainer">
      <div class="best-score">Рекорд: <span id="bestVal">0</span></div>
      <div class="score-hud" id="scoreVal">0</div>
      <canvas id="gameCanvas"></canvas>
      <div class="overlay" id="startScreen">
        <h2>City Bloxx</h2>
        <button class="btn" id="startBtn">Играть</button>
      </div>
      <div class="overlay hidden" id="endScreen">
        <h2 id="endTitle">Игра окончена</h2>
        <div style="font-size:18px;color:#cbd5e1;margin-bottom:20px;">Счет: <span id="finalScore">0</span></div>
        <button class="btn" id="restartBtn">Ещё раз</button>
      </div>
    </div>
  </div>

<script>
  const tgInstance = initTelegramGuard();
  const searchUid = new URLSearchParams(window.location.search).get('uid');

  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const startScreen = document.getElementById('startScreen');
  const endScreen = document.getElementById('endScreen');
  const scoreVal = document.getElementById('scoreVal');
  const bestVal = document.getElementById('bestVal');
  const finalScore = document.getElementById('finalScore');
  const endTitle = document.getElementById('endTitle');

  // Game Constants
  const BLOCK_W = 100;
  const BLOCK_H = 60;
  const ROPE_LEN = 150;
  const SWING_SPEED_BASE = 0.05;

  let width, height;
  let blocks = [];
  let currentBlock = null; // {x, y, w, h, angle, state} state: 'swing', 'drop', 'landed'
  let score = 0;
  let best = Number(localStorage.getItem('stack_best')||0);
  bestVal.textContent = best;
  let state = 'menu'; // menu, playing, gameover
  let cameraY = 0;
  let hue = 0;
  let time = 0;
  let swingSpeed = SWING_SPEED_BASE;
  let resultSent = false;
  let residents = []; // Particles

  function resize(){
    width = canvas.parentElement.clientWidth;
    height = canvas.parentElement.clientHeight;
    canvas.width = width * window.devicePixelRatio;
    canvas.height = height * window.devicePixelRatio;
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    width = width; // logical
    height = height;
  }
  window.addEventListener('resize', resize);
  resize();

  function adjustColor(hex, percent) {
    let num = parseInt(hex.replace("#",""),16),
    amt = Math.round(2.55 * percent),
    R = (num >> 16) + amt,
    G = (num >> 8 & 0x00FF) + amt,
    B = (num & 0x0000FF) + amt;
    return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1);
  }

  function initGame(){
    blocks = [];
    score = 0;
    cameraY = 0;
    hue = Math.random() * 360;
    swingSpeed = SWING_SPEED_BASE; // Reset speed!
    time = 0;
    resultSent = false;
    residents = [];

    // Base block
    blocks.push({
      x: width/2 - BLOCK_W/2,
      y: 0,
      w: BLOCK_W,
      h: BLOCK_H,
      color: `hsl(${hue}, 70%, 50%)`,
      windows: true
    });

    spawnNext();
    scoreVal.textContent = "0";
    state = 'playing';
    startScreen.classList.add('hidden');
    endScreen.classList.add('hidden');
  }

  function spawnNext(){
    score = blocks.length - 1;
    scoreVal.textContent = score;
    hue += 15;

    // Increase swing speed with score
    swingSpeed = SWING_SPEED_BASE + (score * 0.005);
    if(swingSpeed > 0.15) swingSpeed = 0.15;

    currentBlock = {
      w: BLOCK_W,
      h: BLOCK_H,
      color: `hsl(${hue}, 70%, 50%)`,
      state: 'swing',
      angle: 0,
      x: 0,
      y: 0,
      vy: 0
    };
  }

  function gameOver(){
    state = 'gameover';
    if(score > best){
      best = score;
      localStorage.setItem('stack_best', best);
      bestVal.textContent = best;
    }
    finalScore.textContent = score;

    const win = score >= 20;
    endTitle.textContent = win ? "Победа! (+1 балл)" : "Игра окончена";
    endTitle.style.color = win ? "#4ade80" : "#ffffff";

    endScreen.classList.remove('hidden');

    if(!resultSent){
      resultSent = true;
      const res = win ? 'win' : 'loss';
      const uid = tgInstance?.initDataUnsafe?.user?.id || searchUid;
      if(uid){
         fetch('/api/report_game',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({user_id:String(uid), game:'stack', result:res})});
         if(score > 0){
             fetch('/api/add_point',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({user_id:String(uid), game:'stack', delta: score * 2})});
         }
      }
    }
  }

  function dropBlock(){
    if(state !== 'playing') return;
    if(currentBlock.state === 'swing'){
      currentBlock.state = 'drop';
      currentBlock.vy = 0;
    }
  }

  function spawnResidents(bx, by, count){
    // Spawn little dots flying towards the block
    for(let i=0; i<count; i++){
      residents.push({
        x: Math.random() < 0.5 ? -20 : width+20,
        y: height - (by - cameraY) + Math.random()*40,
        tx: bx + BLOCK_W/2 + (Math.random()*40 - 20),
        ty: by + BLOCK_H/2,
        speed: 4 + Math.random()*2,
        color: '#fbbf24', // amber
        life: 60
      });
    }
  }

  function update(){
    time++;

    // Residents
    for(let i=residents.length-1; i>=0; i--){
      const r = residents[i];
      // Target in screen coords
      // Block y is logical Y (0 is bottom).
      // Screen Y = height - (y - cameraY) - ...
      // Let's map target to logical first.

      const dx = r.tx - r.x;
      const dy = (height - (r.ty - cameraY) - BLOCK_H - 100) - r.y; // approximate visual target
      const dist = Math.sqrt(dx*dx + dy*dy);

      if(dist < 10) {
        residents.splice(i,1);
        continue;
      }

      r.x += (dx/dist) * r.speed;
      r.y += (dy/dist) * r.speed;
      r.life--;
      if(r.life <= 0) residents.splice(i,1);
    }

    if(state !== 'playing') return;

    // Crane position (top of stack + rope)
    // The crane pivot point moves up as we build
    const topBlock = blocks[blocks.length-1];
    const stackTopY = topBlock.y + topBlock.h;

    // Crane pivot logic
    // We want the block to swing above the current stack.
    // Pivot Y should be somewhat above.
    const pivotY = stackTopY + ROPE_LEN + 150;
    const pivotX = width / 2;

    if(currentBlock.state === 'swing'){
       // Pendulum
       // angle oscillation
       currentBlock.angle = Math.sin(time * swingSpeed) * 1.2; // +/- 1.2 rad (~70 deg)

       currentBlock.x = pivotX + Math.sin(currentBlock.angle) * ROPE_LEN - currentBlock.w/2;
       currentBlock.y = pivotY - Math.cos(currentBlock.angle) * ROPE_LEN - currentBlock.h;
       // Note: logical Y is up. Visual Y is down.
       // Let's work in visual Y for pendulum and then map to logical?
       // Easier: keep logical Y "up".
       // If pivotY is "up" (e.g. 500), and block hangs down:
       // y = pivotY - cos(a)*L.
       // This matches.

    } else if(currentBlock.state === 'drop'){
       currentBlock.vy -= 0.8; // Gravity (logical Y up, so gravity is negative)
       currentBlock.y += currentBlock.vy;

       // Collision with top block
       if(currentBlock.y <= stackTopY){
         // Check X overlap
         const prev = blocks[blocks.length-1];
         // Allow some tolerance
         const overlap = Math.min(currentBlock.x + currentBlock.w, prev.x + prev.w) - Math.max(currentBlock.x, prev.x);

         if(overlap > 0){
           // Landed
           currentBlock.y = stackTopY;
           currentBlock.state = 'landed';
           currentBlock.windows = true; // Show windows only on landed blocks?

           // Trim block if needed (classic implementation usually doesn't trim, but this one did)
           // Classic City Bloxx: Block wobbles if off-center, stack can fall.
           // This is "Stack" game renamed. Stack game usually trims.
           // User asked for "Style of old game".
           // Old game (City Bloxx) didn't trim size, it had balance.
           // But changing core mechanics from "Trimming Stack" to "Balancing Stack" is risky and complex (physics engine).
           // The user specifically mentioned "crane swinging" and "residents flying".
           // I will keep the "Trimming" mechanic for simplicity and stability unless explicitly asked for physics balance.
           // The user said "implement it in the style of...".
           // Trimming is easier to play on mobile web.
           // I will trim it to simulate "instability" reducing the platform size.

           // Center correction if overlap is good?
           if(Math.abs(currentBlock.x - prev.x) < 5){
             currentBlock.x = prev.x; // Snap
             // Bonus visual?
             spawnResidents(currentBlock.x, currentBlock.y, 5);
           } else {
             spawnResidents(currentBlock.x, currentBlock.y, 2);
           }

           // Trimming logic
           if(currentBlock.x < prev.x){
              // Overlap is on the right side of current
              // current X is left of prev X.
              // Cut left part? No, cut the non-overlapping part.
              // We keep the overlapping part.
              // New width = overlap.
              // New X = prev.x
              currentBlock.w = overlap;
              currentBlock.x = prev.x;
           } else {
              // Current is to the right
              // Cut right part.
              // New width = overlap.
              // X remains currentBlock.x
              currentBlock.w = overlap;
           }

           if(currentBlock.w < 10){
             gameOver();
           } else {
             blocks.push(currentBlock);
             spawnNext();
           }
         } else {
           // Missed
           if(currentBlock.y < stackTopY - 200){ // Fell below
             gameOver();
           }
         }
       }
    }

    // Camera
    // Target: Top block + some margin
    const targetCam = (blocks[blocks.length-1].y) - height * 0.3;
    if(targetCam > 0){
       cameraY += (targetCam - cameraY) * 0.1;
    } else {
       cameraY += (0 - cameraY) * 0.1;
    }
  }

  function draw(){
    ctx.clearRect(0,0,width,height);

    // Draw Residents
    residents.forEach(r => {
      ctx.fillStyle = r.color;
      // Convert to visual
      const sx = r.x;
      const sy = r.y; // Already visual-ish in spawn?
      // Spawn y: height - (by-cam) ...
      // Wait, spawn logic put it in visual coords.
      ctx.beginPath();
      ctx.arc(sx, sy, 3, 0, Math.PI*2);
      ctx.fill();
    });

    // Draw Blocks
    blocks.forEach(drawBlock);

    // Draw Current
    if(state === 'playing' && currentBlock){
      if(currentBlock.state === 'swing'){
        // Draw Rope
        const topBlock = blocks[blocks.length-1];
        const pivotY = topBlock.y + topBlock.h + ROPE_LEN + 150;

        // Logical coords to Screen
        const screenPivotY = height - (pivotY - cameraY) - 50; // Align with block logic
        const screenBlockX = currentBlock.x + currentBlock.w/2;
        const screenBlockY = height - (currentBlock.y - cameraY) - currentBlock.h - 50;

        // Crane Hook
        ctx.strokeStyle = "#94a3b8";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(width/2, screenPivotY); // Pivot is center
        ctx.lineTo(screenBlockX, screenBlockY); // Top of block?
        // Actually block.y is bottom of block. +h is top.
        // screenBlockY is bottom edge visual.
        // We want rope to attach to top of block.
        const screenBlockTop = screenBlockY - currentBlock.h; // Y is inverted in screen?
        // Wait. drawBlock uses: screenY = height - (y - cameraY) - BLOCK_H - 50.
        // This puts the rect at screenY. Rect draws downwards? No fillRect(x,y,w,h).
        // So screenY is Top-Left of rect.
        // So y in logic is "bottom" of stack?
        // blocks[0].y = 0.
        // screenY = height - (0) - 30 - 50 = height - 80.
        // So logic y=0 is drawn at bottom of screen. Correct.
        // currentBlock.y is also logic Y.
        // Pendulum calc sets currentBlock.y.

        // Draw Rope to Top Center of block
        const blockVisualX = currentBlock.x + currentBlock.w/2;
        const blockVisualY = height - (currentBlock.y - cameraY) - currentBlock.h - 50;
        // blockVisualY is Top of block.

        // Pivot Visual
        const pivotVisualY = height - (pivotY - cameraY) - 50;

        ctx.moveTo(width/2, pivotVisualY);
        ctx.lineTo(blockVisualX, blockVisualY);
        ctx.stroke();

        // Draw Crane Head (simple)
        ctx.fillStyle = "#fbbf24";
        ctx.beginPath();
        ctx.arc(width/2, pivotVisualY, 10, 0, Math.PI*2);
        ctx.fill();
      }

      drawBlock(currentBlock);
    }

    // Overlay logic (residents etc)

    requestAnimationFrame(() => {
      update();
      draw();
    });
  }

  function drawBlock(b){
    const screenY = height - (b.y - cameraY) - b.h - 50;

    // Building body
    ctx.fillStyle = b.color;
    ctx.fillRect(b.x, screenY, b.w, b.h);

    // Windows
    if(b.windows){
      ctx.fillStyle = "rgba(255,255,255,0.6)";
      const cols = Math.floor(b.w / 20);
      const rows = 2;
      const marginX = (b.w - cols*10)/ (cols+1);

      for(let r=0; r<rows; r++){
        for(let c=0; c<cols; c++){
             ctx.fillRect(b.x + marginX + c*(10+marginX), screenY + 10 + r*20, 10, 10);
        }
      }
    }

    // Highlight
    ctx.fillStyle = "rgba(255,255,255,0.2)";
    ctx.fillRect(b.x, screenY, b.w, 4);

    // Border
    ctx.strokeStyle = "rgba(0,0,0,0.2)";
    ctx.lineWidth = 1;
    ctx.strokeRect(b.x, screenY, b.w, b.h);
  }

  // Inputs
  const gameArea = document.getElementById('gameContainer');
  gameArea.addEventListener('pointerdown', (e)=>{
     if(state === 'menu' || state === 'gameover') return;
     dropBlock();
  });

  document.addEventListener('keydown', (e)=>{
    if(e.code === 'Space' && state === 'playing'){
      dropBlock();
      e.preventDefault();
    }
  });

  document.getElementById('startBtn').addEventListener('click', initGame);
  document.getElementById('restartBtn').addEventListener('click', initGame);

  (async()=>{
    if(!tgInstance) return;
    await ensureNicknameOrRedirect();
  })();

  // Start loop
  requestAnimationFrame(() => {
      update();
      draw();
  });

</script>
</body>
</html>
